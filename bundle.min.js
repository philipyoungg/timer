'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
  'use strict';

  var Timer = function () {
    function Timer() {
      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Timer);

      this.target = target * 1000;
      this.isTicking = false;
      this.onUpdate = options.onUpdate;
    }

    _createClass(Timer, [{
      key: 'init',
      value: function init() {
        this.reference = Date.now();
        this.elapsed = 0;
        this.timeOnPaused = 0;
        this.left = this.target;
        this.progress = 0;
        this.update();
      }
    }, {
      key: 'refresh',
      value: function refresh() {
        if (this.left < 0) {
          this.left = 0;
          this.update();
          clearTimeout(this.timeout);
        } else {
          this.elapsed = Date.now() - this.reference + this.timeOnPaused;
          this.left = this.target - this.elapsed;
          this.progress = this.elapsed / this.target;
          this.update();
          this.timeout = setTimeout(this.refresh.bind(this), 10);
        }
      }
    }, {
      key: 'pause',
      value: function pause() {
        this.isTicking = false;
        clearTimeout(this.timeout);
        this.timeOnPaused = this.elapsed;
      }
    }, {
      key: 'play',
      value: function play() {
        if (!this.isTicking) {
          this.isTicking = true;
          this.reference = Date.now();
          this.refresh();
        }
      }
    }, {
      key: 'update',
      value: function update() {
        this.onUpdate({
          secondLeft: Math.round(this.left / 1000),
          progress: this.progress
        });
      }
    }, {
      key: 'reset',
      value: function reset() {
        this.isTicking = false;
        clearTimeout(this.timeout);
        this.init();
      }
    }]);

    return Timer;
  }();

  var c = document.querySelector('canvas');
  c.width = 200;
  c.height = 200;
  c.style.width = '100px';
  c.style.height = '100px';
  var ctx = c.getContext('2d');
  ctx.scale(2, 2);

  var indicatorSize = 5;
  var indicatorColor = 'red';
  var placeholderColor = 'rgba(0,0,0,0.1)';

  var timeText = function timeText(ctx, value) {
    ctx.lineWidth = indicatorSize;
    ctx.font = 'bold 21px Arial';
    ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(value, c.width / 4, c.height / 4);
  };

  var placeholder = function placeholder(ctx) {
    ctx.lineWidth = indicatorSize;
    ctx.strokeStyle = placeholderColor;
    ctx.beginPath();
    ctx.arc(c.width / 4, c.height / 4, c.width / 4 - indicatorSize, 0, Math.PI * 2);
    ctx.stroke();
  };

  var timeIndicator = function timeIndicator(ctx, value) {
    var start = Math.PI * 1.5;
    ctx.strokeStyle = indicatorColor;
    ctx.beginPath();
    ctx.arc(c.width / 4, c.height / 4, c.width / 4 - indicatorSize, start, start + Math.PI * 2 * value);
    ctx.stroke();
  };

  placeholder(ctx);
  timeText(ctx, '-');

  var padToTwo = function padToTwo(num) {
    return num < 10 ? '0' + num : num;
  };

  var updateView = function updateView(status) {
    var ml = Math.floor(status.secondLeft / 60);
    var sl = status.secondLeft % 60;
    ctx.clearRect(0, 0, c.width, c.height);
    placeholder(ctx);
    timeText(ctx, padToTwo(ml) + ':' + padToTwo(sl));
    timeIndicator(ctx, status.progress);
  };

  var time = new Timer(1500, {
    onUpdate: updateView
  });

  time.init();

  document.getElementById('pause').onclick = function () {
    return time.pause();
  };

  document.getElementById('play').onclick = function () {
    return time.play();
  };

  document.getElementById('reset').onclick = function () {
    return time.reset();
  };
})();

